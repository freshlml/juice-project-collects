package com.project.normal.fd;

public class FloatTest {

    public static void main(String argv[]) {

        /**
         *浮点数的精度问题
         *1、计算机存储的是二进制数
         *
         *2、十进制整数和二进制数的转换
         * 11
         *  11/2=5   余   1
         *  5/2=2   余   1
         *  2/2=1   余   0
         *  1/2=0   余   1
         *  0结束   11二进制表示为(从下往上): 1011
         *这里提一点：只要遇到除以后的结果为0了就结束了，大家想一想，所有的整数除以2是不是一定能够最终得到0。
         * 换句话说，所有的整数转变为二进制数的算法会不会无限循环下去呢？绝对不会，整数永远可以用二进制精确表示 ，但小数就不一定了。
         *
         *3、十进制小数和二进制数的转换
         * 算法是乘以2直到没有了小数为止。举个例子，0.9表示成二进制数
         *   0.9*2=1.8   取整数部分  1
         *   0.8(1.8的小数部分)*2=1.6    取整数部分  1
         *   0.6*2=1.2   取整数部分  1
         *   0.2*2=0.4   取整数部分  0
         *   0.4*2=0.8   取整数部分  0
         *   0.8*2=1.6   取整数部分  1
         *   0.6*2=1.2   取整数部分  1  出现重复了，所以会无限计算下去
         *   .........      0.9二进制表示为(从上往下): 111'0011'0011'0011'0011'0011...
         *注意：上面的计算过程循环了，也就是说*2永远不可能消灭小数部分，这样算法将无限下去。很显然，小数的二进制表示有时候是不能精确的。
         * 其实道理很简单，十进制系统中能不能准确表示出1/3呢？同样二进制系统也无法准确表示1/10。这也就解释了为什么浮点型减法出现了"减不尽"的精度丢失问题。
         *
         *4、浮点数的存储
         *以float为例，float四个字节表示
         * float内存存储结构
         *
         *         4bytes         31(1位)      30(1位)      29----23(7)位    22----0(23位)
         *
         *                      实数符号位      指数符号位         指数位          有效数位
         *
         *         其中符号位1表示正，0表示负。有效位数位24位(1位整数和23位小数)
         *
         * 将十进制小数转化为二进制存储的步骤为：
         *
         *      （1）先将这个实数的绝对值化为二进制格式，注意实数的整数部分和小数部分的二进制方法在上面已经探讨过了。
         *      （2）将这个二进制格式实数的小数点左移或右移n位，直到小数点移动到第一个有效数字的右边。
         *      （3）从小数点右边第一位开始数出二十三位数字放入第22到第0位。
         *      （4）如果实数是正的，则在第31位放入“0”，否则放入“1”。
         *      （5）如果n 是左移得到的，说明指数是正的，第30位放入“1”。如果n是右移得到的或n=0，则第30位放入“0”。
         *      （6）如果n是左移得到的，则将n减去1后化为二进制，并在左边加“0”补足七位，放入第29到第23位。如果n是右移得到的或n=0，则将n化为二进制后在左边加“0”补足七位，再各位求反，再放入第29到第23位。
         *
         *  举例说明： 11.9的内存存储格式
         *
         *        (1) 将11.9化为二进制后大约是" 1011.111'0011'0011'0011'0011'0..."。
         *
         *        (2) 将小数点左移三位到第一个有效位右侧： "1.011'111'0011'0011'0011'0011'0 "。 保证有效位数24位，右侧多余的截取（误差在这里产生了 ）。
         *
         *        (3) 这已经有了二十四位有效数字，将最左边一位“1”去掉，得到“ 011'111'0011'0011'0011'0011'0 ”共23bit。将它放入float存储结构的第22到第0位。
         *
         *        (4) 因为11.9是正数，因此在第31位实数符号位放入“0”。
         *
         *        (5) 由于我们把小数点左移，因此在第30位指数符号位放入“1”。
         *
         *        (6) 因为我们是把小数点左移3位，因此将3减去1得2，化为二进制，并补足7位得到0000010，放入第29到第23位。
         *
         *    最后表示11.9为：  0 1 0000010 011'111'0011'0011'0011'0011'0
         *
         *所以，important!!! 小数(十进制)存储到计算机中(二进制)时精度就可能丢失了,运算之后精度更是不能保证
         *浮点数适合与科学计算和工程计算，不适合于业务计算
         *
         *
         *Java中double类型的格式基本遵循IEEE 754标准。尽管数学意义上的小数是连续的，但double仅仅能表示其中的一些离散点，把这些离散点组成的集合记为S，S的大小还是有限的。
         * 如果要保存的小数P刚好在集合S内，那么double类型就能精确的表示P；否则double类型只能从集合S中找一个与P最近的离散点P'代替P。
         *
         *
         *
         */







    }


}
