package com.juice.jv.lang;

public class NumTest {
    /**
     *第一: 数的表示方法: 取Long的范围：[-2^63, 2^63-1]
     *      -2^63            -2^63 + 1           -2^63 + 2        ...    -1                 0                   1               ...   2^63-2            2^63-1
     * 原码  1,000 ,,, 0000   1,111 ,,, 1111      1,111 ,,, 1110   ...    1,000 ,,, 0001     0,000 ,,, 0000      0,000 ,,, 0001  ...   0,111 ,,, 1110    0,111 ,,, 1111
     * 补码  1,000 ,,, 0000   1,000 ,,, 0001      1,000 ,,, 0010   ...    1,111 ,,, 1111     0,000 ,,, 0000      0,000 ,,, 0001  ...   0,111 ,,, 1110    0,111 ,,, 1111
     *
     *第二: 数的加减法
     *补码加减计算原理: 补码数轴滚动
     *
     *第三: 减法转化成加法
     *减去一个数 <==> 加上这个数的负数，存在一个例外情况: 当减去Long.MIN_VALUE时，Number - Long.MIN_VALUE != Number + (-Long.MIN_VALUE)
     *
     *第四: 计算一个数的负数
     *在数之前写负号。例外: 0添加负号还是0; -Long.MIN_VALUE = Long.MIN_VALUE 而不等于 2^63
     *
     *第五: 乘法
     * 数运算，补码数轴滚动；符号运算
     * a * b 越界判断:
     *   |a| > MAX ÷ |b|
     *第六: 除法
     *  除数 / 被除数 = 商 ... 余
     *  1.数运算: |除数| 按 |被除数| 个数 分成了几组，不够一组的数量余下多少
     *  2.符号运算，商的符号=除数，被除数的符号运算
     *            余的符号和除数一致
     *  3. eg: -127/2 = -63 ... -1 , -127 每 2 个一组，分成-63组余-1 (另外，floorMod {@link Math#floorMod(int, int)})
     *
     *第七: 类型转换
     *                                       -128                          -1                   0                         127
     *                                    1000 0000    ...             1111 1111            0000 0000  ...            0111 1111
     *          -65536                       -128                          -1                   0                         127           128                    65535
     *  1000 0000 0000 0000 ... 1111 1111 1000 0000    ...   1111 1111 1111 1111  0000 0000 0000 0000  ...  0000 0000 0111 1111 0000 0000 1000 0000 ... 0111 1111 1111 1111
     * 小类型转大类型，只需正数补0，负数补1，不改变数的值，√
     * 大类型转小类型，只需不超过小类型范围，截断即可 √
     *
     */



}
