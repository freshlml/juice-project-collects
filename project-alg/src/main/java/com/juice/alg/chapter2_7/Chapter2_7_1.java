package com.juice.alg.chapter2_7;

public class Chapter2_7_1 {

    //快速排序，最坏情况运行时间分析
    //有序: O(n);  逆序: O(n^2)
    /*假设每次partition产生9:1划分的递归树
                                    [n]
                    [9/10*n]                        [1/10*n]                 1, n/10               n/(10/9)
          [9^2/10^2*n]     [9/10*1/10*n]  [9/10*1/10*n]     [1^2/10^2*n]     2, n/10^2             n/(10/9)^2
            ...
                                                                     [1]     x, n/10^x
            ...
          [1]                                                                                   y, n/(10/9)^y
        n/10^x = 1      ==> x = log10(n)   <  log2(n)
        n/(10/9)^y = 1  ==> y = log10/9(n) <  Clog2(n); C >= 7

       假设每次partition产生(1-α):α的划分
       log(1/α)[n]，log(1/(1-α))[n]
       不妨令0<α<=1/2，则最坏情况运行时间 =  n*log(1/(1-α))[n]
                                     <= n*C*lgn ===> C >= -(1/lg(1-α)) >= 1 ，越不平衡的划分导致更大的系数

       partition按比例划分的最坏情况运行时间:
            O(n*lgn)

       练习7.2-6: 画图解法
       或  1-α-a = α+a ==> 2*a = 1-2α
     */

    //快速排序，平均情况运行时间分析
    /*输入序列假设:  n个数互异且均匀随机排列
      P(逆序) = 1/n!
      P(有序) = 1/n!
      P(任一位置取任一值) = 1/n

      随机变量X:  第一次partition返回的下标q
          取值:  0     1       2       ...     n-1
         P(X):
      P(X=i) = 1/n, 0<=i<=n-1
      EX = 0*1/n + 1*1/n + ... + (n-1)*1/n = (n-1)/2


      随机变量Y:  第二次partition返回的下标q
          取值:  0     1      2       ...   i    ...   n-1   ,i为第一次partition返回的下标q
         P(Y):
      P(Y=0) = todo,如何求呢

     */



}
