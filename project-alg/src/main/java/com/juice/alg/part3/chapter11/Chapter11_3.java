package com.juice.alg.part3.chapter11;

public class Chapter11_3 {

    /**
     *hash 函数（散列函数）
     *
     *  将元素映射到桶下标（0 ~ m-1），假设桶的大小为 m。
     *
     *  确定性: 散列函数任何时候调用，始终返回相同的结果
     *  相等性: hash(key1) == hash(key2) where key1 == key2 (optional)
     *
     *  一个好的散列函数应(近似)满足每个元素被等可能的散列到 m 个槽中的任何一个，并与其他元素已散列到哪个槽位无关。遗憾的是一般无法检测这一条件是否成立。
     *
     *  如，一个序列中元素的关键字 key 均匀的分布于 [0, 1) 区间之中，则散列函数可以是: `key * m`。
     *
     *  散列函数的设计可能与序列中元素的特异值有关。例如，在一个编译器的符号表中，常常出现一些很相近的符号，如 pt，pts。则一个好的散列函数应该将这些相近符号散列到相同槽的可能性最小化。
     *
     *  一个好的散列函数，在某种程度上应独立于数据可能存在的任何模式。例如除法散列中用一个特定的素数来除所给的关键字，所得余数为该关键字的散列值。假定所选择的素数与关键字分布
     *  中的任何模式无关，这种方法常常可以得出好的结果。
     *
     *
     *除法散列法
     *  取元素的关键字 key，计算 key 对 m 的余数，即可将元素映射到 0 ~ m-1 下标范围之中: `key mod m`。
     *
     *  当 m = 2^p 时，hash(key) 的值就是 key 的 p 个最低位数字。除非已知各种最低 p 位的排列形式是等可能的，否则，在设计散列函数时，最好考虑关键字的所有位。
     *
     *  除法散列法改进: {@link java.util.HashMap}
     *
     *乘法散列法
     *  取元素关键字 key，乘以常数 A（0 < A < 1）。提取 key*A 的小数部分，在以 m 乘以这个值后向下取整: `⌊m * (key*A mod 1)⌋`。
     *
     *  乘法散列法的一个优点是对 m 的选择不是非常关键，一般选择它为 2 的某个幂次。
     *
     *  ...
     *
     *全域散列法
     *  todo
     *
     */
    public static void main(String[] argv) {

    }

    //练习11.3-1
    //  先比较散列值，如果散列值相等，在比较关键字。如果散列值不相等，则关键字不相等

    //练习11.3-2
    //  假设 w = 2, m = 10, key = 1121 占用两个 w
    //    1. 取 1121 的最高 w(=2) 位，得到 11，除以 m(=10)，得到余数 1
    //    2. 将余数 1 拼接到 21，得到 121，重复执行第 "1" 步

    //练习11.3-3
    //  m = 2^p - 1. key = x * (2^p)^(r-1) + x * (2^p)^(r-2) + ... + x * (2^p) + x
    //  key mod n = (x * (2^p)^(r-1) + x * (2^p)^(r-2) + ... + x * (2^p) + x) mod m
    //            = [ (x * (2^p)^(r-1)) mod m + (x * (2^p)^(r-2)) mod m + ... + (x * (2^p)) mod m + x mod m ] mod m
    //            = todo

    //练习11.3-5 todo
    //练习11.3-6 todo
}
