package com.juice.alg.part3.chapter11;

public class Chapter11_3 {

    /**
     *散列函数
     *
     *  一个正确的散列函数需要将元素映射到桶下标（0 ~ m-1，假设桶的大小为 m）。
     *
     *  确定性: 散列函数任何时候调用，始终返回相同的结果
     *  相等性: h(key1) == h(key2) where key1 == key2 (optional)
     *
     *  一个好的散列函数应(近似)满足每个元素被等可能的散列到 m 个槽中的任何一个，并与其他元素已散列到哪个槽位无关。遗憾的是一般无法检测这一条件是否成立，因为很少能够知道关键字满足何种分布。
     *
     *  如，一个序列中元素的关键字 key 均匀的分布于 [0, 1) 区间之中，则散列函数可以是: `key * m`。
     *
     *  散列函数的设计可能与序列中元素的特异值有关。例如，在一个编译器的符号表中，常常出现一些很相近的符号，如 pt，pts。则一个好的散列函数应该将这些相近符号散列到相同槽的可能性最小化。
     *
     *  一个好的散列函数，在某种程度上应独立于数据可能存在的任何模式。例如除法散列中用一个特定的素数来除所给的关键字，所得余数为该关键字的散列值。假定所选择的素数与关键字分布
     *  中的任何模式无关，这种方法常常可以得出好的结果。
     *
     *
     *除法散列法
     *  取元素的关键字 key (假设 key 为整数)，计算 key 对 m 的余数，即可将元素映射到 0 ~ m-1 下标范围之中: `key mod m`。
     *
     *  当 m = 2^p 时，`key mod m` 的值就是 key 的 p 个最低二进制位。除非已知各种最低 p 位的排列形式是等可能的，否则，在设计散列函数时，最好考虑关键字的所有位。
     *
     *  当 m = 2^p 时，取余运算可用位运算代替: {@link java.util.HashMap}
     *
     *乘法散列法
     *  取元素关键字 key (假设 key 为整数)，乘以常数 A（0 < A < 1）。提取 key*A 的小数部分，在以 m 乘以这个值后向下取整: `⌊m * (key*A mod 1)⌋`。
     *
     *  乘法散列函数的计算:
     *  Ⅰ: 根据公式计算（要用到浮点数运算），`⌊m * (key*A mod 1)⌋` = `⌊m * (key*A - ⌊key*A⌋)⌋`
     *  Ⅱ: 等价转换，使得只需进行整数运算和位运算
     *      key ∈ [0, 2^w), 其中 w 表示整数的位宽减一，如一个 int 型整数有 32 位，w = 32 - 1 = 31
     *      令 A = s/2^w, 其中 s ∈ (0, 2^w), 则 A ∈ (0, 1)
     *      令 m = 2^p, p ∈ [0, w)
     *
     *      key * s = key * (A * 2^w) = r1 * 2^(w+1) + r0   // A 的值不宜过小，要保证 A * 2^w >= 1, 同时要保证 A * 2^w ∈ Z，即 A ∈ [0.0.....1, 0.1.....1]
     *                                                                                                                          |<=w位|    |<=w位|
     *      可以证明 r0 部分去掉最高位后的 p 个最高有效位等于 `⌊2^p * (key*A - ⌊key*A⌋)⌋` 的运算结果:
     *                          |- a -|- b -|
     *        令 key * A = a.b = -----.-----                // key * A 的结果要不丢失精度的保存，则需要有 2*w 个有效位的浮点数类型
     *                          |<=w位|<=w位|
     *
     *        ⌊2^p * (key*A - ⌊key*A⌋)⌋ = ⌊2^p * 0.b⌋ = b 部分的 p 个最高有效位
     *
     *                                                                   |- a-|- b -|
     *        key * s = key * (A * 2^w) = (key * A) * 2^w = a.b * 2^w = ~-----|-----~.
     *                     <左右两式没有精度丢失，故此等号成立>               |- r1-|- r0 -|
     *
     *全域散列法
     *  todo
     *
     */
    public static void main(String[] argv) {
        //验证乘法散列法 "等价转换" 的例子
        int w = 31;
        int key = 0b0010_1111_1011_0010_0010_1011_1111_0011;
        System.out.println(Integer.toHexString(key));  // key = 2f_b2_2b_f3 = 0010_1111 1011_0010 0010_1011 1111_0011

        float A = 0x0.2dec1P0f;                        // A = 0.0010_1101_1110_1100_0001
        double l1 = (double) key * A;
        System.out.println(Long.toHexString(Double.doubleToLongBits(l1))); // l1 = key * A = 41_a1_1c_99_ea_bb_86_60
                                                       //                            = 1 0001 0000 1100 1001 1001 1110 101.0 1011 1011 1000 0110 0110 0000
                                                       // l1 * 2^w = (key * A) * 2^w = 1 0001 0000 1100 1001 1001 1110 101|0 1011 1011 1000 0110 0110 0000 0000 00
                                                       //                            = 100 0100_0011 0010_0110 0111_1010 1|010_1110 1110_0001 1001_1000 0000_0000
        long l2 = (long) (l1 * Math.pow(2, w));
        System.out.println(Long.toHexString(l2));      // l2 = l1 * 2^w = (key * A) * 2^w  = 4_47_26_7a_ae_e1_98_00 = l3

        int s = (int) (A * Math.pow(2, w));
        System.out.println(Integer.toHexString(s));    // s = 16_f6_08_00 = 0001_0110 1111_0110 0000_1000 0000_0000

        long l3 = (long) key * (long) s;
        System.out.println(Long.toHexString(l3));      // l3 = key * s = key * (A * 2^w) = 4_47_26_7a_ae_e1_98_00
                                                       //              = 0000_0100 0100_0111 0010_0110 0111_1010 1|010_1110 1110_0001 1001_1000 0000_0000
        int p = 5;
        int l4 = (int) ((l3 & 0x00_00_00_00_7f_ff_ff_ff) >>> (w-p));
        System.out.println(Integer.toHexString(l4));   // l4 = b = 1011

        int l5 = (int) ((l1 - (int)l1) * Math.pow(2, p));
        System.out.println(Integer.toHexString(l5));   // l5 = b = 1011 = l4
    }

    //练习11.3-1
    //   先比较散列值，如果散列值相等，再比较关键字。如果散列值不相等，则关键字不相等。hash == e.hash && key == e.key

    //练习11.3-2
    //  假设 w = 2, m = 10, key = 1121 占用两个 w
    //    1. 取 1121 的最高 w(=2) 位，得到 11，除以 m(=10)，得到余数 1
    //    2. 将余数 1 拼接到 21，得到 121，重复执行第 "1" 步

    //练习11.3-3
    //  m = 2^p - 1. key = x * (2^p)^(r-1) + x * (2^p)^(r-2) + ... + x * (2^p) + x
    //  key mod n = (x * (2^p)^(r-1) + x * (2^p)^(r-2) + ... + x * (2^p) + x) mod m
    //            = [ (x * (2^p)^(r-1)) mod m + (x * (2^p)^(r-2)) mod m + ... + (x * (2^p)) mod m + x mod m ] mod m
    //            = todo

    //练习11.3-5 todo
    //练习11.3-6 todo
}
