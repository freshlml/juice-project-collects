package com.juice.alg.chapter1_5;

public class Chapter1_5 {

    /**
     *算法运行时间分析: 即分析算法的运行时间，主要有两个影响因素:
     *                  1.输入规模n
     *                  2.输入序列的何种排列，如三个数编号为1 2 3，其输入的排列是如下所有排列中的一种
     *                    1 2 3； 1 3 2； 2 1 3； 2 3 1； 3 1 2； 3 2 1
     *              最坏情况运行时间(时间复杂度)，平均情况运行时间，期望运行时间
     *
     *   最坏情况运行时间: 即算法最坏情况的运行时间。算法在特定排列的输入序列下的最长运行时间。
     *                  如插入排序中，逆序的输入序列，里层循环最坏情况总是比较j次
     *                  如快速排序中，逆序的输入序列，partition返回的q位置的最坏情况总是end-1
     *
     *                 意义: 最坏情况运行时间是一个保底时间，一旦正确给出，就不会有比它更长的运行时间
     *                 考虑点: 最坏情况可能经常出现，这取决于输入序列是否更加倾向于选择使算法达到最坏情况的排列
     *
     *   平均情况运行时间: 算法在输入序列的全排列下运行时间的加权平均数
     *                   输入序列的排列  排列1   排列2   ...   排列i   ...
     *                   概率          P1     P2     ...    Pi    ...
     *                   运行时间       T1     T2     ...    Ti    ...
     *                 平均情况运行时间: P1*T1 + P2*T2 + ... + Pi*Ti + ...
     *                 如何知道输入序列取某一排列的概率呢，答案是不知道。在实际情况中，要么已知输入序列满足特定的分布，或者假设输入序列的分布
     *                 a:输入序列的分布假设
     *                   1).输入序列满足一定的分布
     *                   2).或者，假设输入序列满足特定的分布。如"均匀随机"的，即输入序列取全排列中任意一种排列的概率都相等
     *                 b:基于输入序列的分布，就可以求解概率
     *
     *                 意义: 小的平均情况运行时间意味着 更大运行时间 的 概率更小
     *                 考虑点: 通常需要采用"随机算法"将序列打乱，从而使得输入序列满足"假设的分布"
     *
     *                 平均情况运行时间的求解: 根据定义解 或者
     *                           从概率角度计算运行时间。如插入排序的里层循环，从概率角度计算需要比较的次数
     *                               1).假设输入序列的分布，输入序列的分布决定事件的概率
     *                               2).通常可以抽象出一个随机变量，求解随机变量(可以给出其试验帮助求解)
     *
     *   期望运行时间: 通过随机数生成器将输入序列打乱，使打乱后的序列满足一定的分布，从而计算出来的时间
     *              它等于使用同样的输入序列分布的平均情况运行时间
     *
     *   对于一个算法，最坏情况运行时间通常是固定的，但可以优化平均情况运行时间，
     *   可以假设输入序列满足特定的分布，并且在该分布下有比较小的平均情况运行时间，
     *   然后使用随机数生成器创造满足该分布的输入序列，就可以得到比较小的期望运行时间(等于需要的比较小的平均情况运行时间)
     *
     */

    /**
     *雇用问题(找最值)
     *  依次n个应聘者，如果发现当前面试者更合适，就雇用当前的，直到面完第n个
     *
     *list[n]
     *person = lowest;
     *for i from 1 to n:
     *   if(decide(list[i], person)):  # 如果当前面试者更合适
     *      person = list[i]  # 辞掉person, 雇用当前面试者，雇用一个面试者花费费用记为C
     *
     *第一: 最坏情况运行时间
     *  = C1*n + C2*m ;C1为for,if语句的时间之和, C2为雇用面试者语句的时间
     *  = O(n)  ;m<=n,最坏情况下m=n
     *
     *第二: 平均情况运行时间
     *  = C1*n + C2*m ;C1为for,if语句的时间之和, C2为雇用面试者语句的时间
     *  = O(n)   ;m<=n,平均情况下m=EX∈[ln(n), ln(n+1)]
     *
     *第三: 面试n个人花费的总费用的问题，每雇用一个面试者需花费C的费用
     * 最坏情况的费用: C*n
     * 平均情况的费用:
     *  面试n个人，可能第一个就是最佳的，将最多雇用一次，花费1*C
     *  面试n个人，可能第二个才是最佳的，将最多雇用两次，花费2*C
     *  面试n个人，可能第n个才是最佳的，将最多雇用n次，花费n*C
     *===>输入序列的不同导致不同的总费用，像这类输入序列导致不同结果的问题，应该进行概率分析
     * 随机变量X: 雇用的人数 (找到最值所需的替换次数=m)
     * X的取值: 1,   2,    3,   ...,  n
     *  P(X): P(1) p(2)  p(3)       P(n)
     *
     * 总费用: C*X
     * 总费用期望: C*EX
     *
     * 试验:    依次独立重复的面试n个人
     * 基本事件: (雇，雇/不雇，... ，雇/不雇)，共n个人
     * 样本空间: { (雇，雇/不雇，... ，雇/不雇) }, 共2^(n-1)个元素
     *
     *如何求P(X)
     * 基本事件概率: 1. P(第i个人被雇用的概率) = 1/i 这建立在输入序列的分布假设上，可见面试每一个人被雇佣的概率都不一样
     *            2. P(基本事件) 也很不一样
     *  则   P(X=1) = (n-1)! / n! = 1/n
     *      P(X=2) = ...
     *      P(X=3) 不好求 ...
     *
     *输入序列的分布假设 { 输入序列的分布决定事件的概率
     *     均匀随机的排列
     * 下标 1,       2, ..., n
     * 排名 rank(1) rank(2)  rank(n)  rank(i)表示第i位应聘者的排名
     *     <rank(1), rank(2), ..., rank(n)>是其中一种排列方式
     *     <rank(2), rank(1), ..., rank(n)>也是
     *     这样的排列有A(n,n) = n!, 每一种排列方式等概率
     *}
     *当P(X)不好求时，作如下分解
     *    X = X1 + X2 +...+ Xi +...+ Xn, Xi表示第i个人是否被雇用 = 1， 被雇佣
     *                                                         0，不被雇用
     *       P(Xi) = 1/i
     *
     *    EX = EX1 + EX2 +...+ EXi +...+ EXn
     *       = 1/1 + 1/2 +...+ 1/i +...+ 1/n
     *
     *    令f(x) = 1/x, f(x)递减
     *      上界: ∫(1,n) f(x)dx = ∫(1,n) 1/xdx = ln(n)
     *      下界: ∫(1,n+1) f(x)dx = ∫(1,n+1) 1/xdx = ln(n+1)
     *
     *第四: 输入序列的分布如果使均匀随机的，则平均情况费用为C*lnn
     *     而实际情况是，输入序列不一定是均匀随机的，则可使用随机数创造一个均匀随机的序列，这样期望费用=平均情况费用
     *
     *为雇用问题创造随机输入序列: 使用随机数生成器产生n个数的随机序列，且该序列满足上述输入序列的分布假设
     *person = lowest;
     *list[n]
     *person = lowest;
     *for i from 1 to n:
     *    r = RANDOM(i, n)  # 等概率的在i ~ n中产生数字
     *    if(decide(list[r], person)):
     *       person = list[r]
     *    swap list[i], list[r]  # 秀
     *
     *
     *RANDOM(1,n): 等可能(1/n概率)的随机的产生数字1 ~ n
     *    将RANDOM(1, n)调用n次
     *            i1 i2 i3 ... in     1/n*1/n*...*1/n= 1/n^n 概率  @link Chapter1_5-1
     *
     *    将RANDOM(1, n)调用n次，且i不重复
     *            i1 i2 i3 ... in     1/n * [(1/n) / (n-1)/n] * [(1/n) / (n-2)/n] *... = 1/n!
     *
     *rd[n] = F[RANDOM(1, n)]... 不重复的产生n个数的随机序列
     *list[n]
     *person = lowest;
     *for i from 1 to n:
     *    r = rd[i]
     *    if(decide(list[r], person)):  # 如果当前面试者更合适
     *       person = list[r]  # 辞掉person, 雇用当前面试者，雇用一个面试者花费费用记为C
     *
     */


}
