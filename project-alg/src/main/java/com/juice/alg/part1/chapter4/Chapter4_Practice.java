package com.juice.alg.part1.chapter4;

public class Chapter4_Practice {

    /*思考题4-5,芯片检测
      A B C
      1). 检测 B-C，假设得出结果"好-好"，则 B 和 C 状态一致，但不能确定他们是好是坏
      2). 检测 A-B
          若得出结果"好-好"，则 A 和 B 状态一致，但不能确定他们是好是坏
          若得出结果"好-坏"，则 A 是坏的，B 不能确定
          若得出结果"坏-好"，则 B 是坏的，A 不能确定
          若得出结果"坏-坏"，则 A，B 都不能确定是好是坏
      可见，对所有芯片两两检测，不能确定芯片的状态。注: n 个芯片，两两检测，共 n*(n+1)/2 种结果

      a. 证明: 如果超过 n/2 块芯片是坏的，则任何基于这种逐对检测的策略都无法确定哪些芯片是好的
        todo
        取某个芯片，与其他芯片逐一检测，得到 n-1 个其他芯片报告的结果，可相信的报告结果 < n/2，其他芯片报告的"好"/"坏"的总数可能 > n/2, 也可能 < n/2

      假定 n 个芯片中超过 n/2 块芯片是"好"的。测定一块芯片好坏的方法: 用该芯片与其他芯片逐一测试，统计其他芯片的报告结果
        1. 若 n 为偶数。该芯片记为 A
           若 A 为坏芯片，则其他芯片报告的结果为"坏"的数量 >= n/2 + 1，将 A 错误报告为"好"的数量 <  n/2 - 1
           若 A 为好芯片，则其他芯片报告的结果为"好"的数量 >= n/2，    将 A 错误报告为"坏"的数量 <  n/2
        2. 若 n 为奇数。该芯片记为 A
           若 A 为坏芯片，则其他芯片报告的结果为"坏"的数量 >= n/2 + 1，将 A 错误报告为"好"的数量 <  n/2
           若 A 为好芯片，则其他芯片报告的结果为"好"的数量 >= n/2，    将 A 错误报告为"坏"的数量 <= n/2
      故: 将 A 与其他芯片注意测试，若报告为"坏"的数量 >= n/2 + 1，则该芯片为"坏"芯片，若报告为"好"的数量 >= n/2，则该芯片为"好"芯片

      b & c. 假定 n 个芯片中超过 n/2 块芯片是"好"的. 求如何检测出一块好的芯片
        1. 两两配对，保留所有结果是"好-好"的检测对，每个检测对留一片丢一片。
        2. 如果是其他情况全丢掉，剩下的芯片仍然满足好芯片多于坏芯片的假设。

        T(n) = T(n/2) + O(n)
     */
    int find(int[] a) {

        int n = a.length;

        if(n == 1) return a[0];
        if(n == 2) return a[0];

        boolean flag = (n % 2 != 0) && !isBad(a, n-1); //如果 n 为奇数，并且 a[n-1] 不是坏芯片
        if(flag) return a[n-1];

        int[] b = new int[n/2];
        //两两配对
        int j = 0;
        for(int i=0; i<n/2; i++) {
            if(check(a[i], a[n/2 + i]) == 0) { //"好-好"的检测结果，留一片丢一片
                b[j++] = a[i];
            }
            //其他舍弃
        }

        int r = find(b);
        return r;
    }
    //0: 好-好, 1: 好-坏, 2: 坏-好, 3: 坏-坏
    int check(int a, int b) {return 0;}
    boolean isBad(int[] a, int idx) {
        int n = a.length;
        int mi = n/2;
        int p = a[idx];
        int g = 0, h = 0;
        for(int i=0; i<n; i++) {
            if(i == idx) continue;
            int pj;
            if((pj = check(p, a[i])) == 1 || pj == 3) {
                h++;
                if(h >= mi + 1) return true;
            } else {
                g++;
                if(g >= mi) return false;
            }
        }
        return h >= mi + 1;
    }
}
