package com.juice.alg.part1.chapter5;

public class Chapter5 {
    /**
     *算法运行时间分析: 即分析算法的运行时间，主要有两个影响因素:
     *   1.输入规模 n
     *   2.输入序列的何种排列，如三个数编号为 1 2 3，其输入的排列是如下所有排列中的一种
     *     1 2 3； 1 3 2； 2 1 3； 2 3 1； 3 1 2； 3 2 1
     *
     *  最坏情况运行时间(就是之前所说的时间复杂度)、平均情况运行时间、期望运行时间
     *
     *
     *一. 最坏情况运行时间
     *  算法在最坏情况下的运行时间（算法在特定排列的输入序列下的最长运行时间）
     *
     *  如，插入排序中，逆序的输入序列，里层循环最坏情况的比较次数总是达到最多
     *  如，快速排序中，逆序的输入序列，每次 partition 返回的 q 位置总是只能并掉一个元素(而不是最好情况的一半元素)
     *
     *  意义: 最坏情况运行时间是一个保底时间，一旦正确给出，就不会有比它更长的运行时间
     *  考虑点: 最坏情况可能经常出现，这取决于输入序列是否更加倾向于选择使算法达到最坏情况的排列
     *
     *二. 平均情况运行时间
     *   算法在输入序列的所有可能排列下运行时间的加权平均数
     *
     *   输入序列的排列  排列1   排列2   ...   排列i   ...
     *           概率   P1     P2    ...    Pi    ...
     *        运行时间   T1     T2    ...    Ti    ...
     *   平均情况运行时间 = P1*T1 + P2*T2 + ... + Pi*Ti + ...
     *   从定义看，如果每一种排列的运行时间相同或者没有太大差别，平均情况运行时间将等于任意一种排列的运行时间
     *
     *   意义: 小的平均情况运行时间意味着出现 "更大运行时间" 的排列的概率更小
     *   考虑点: 通常需要采用"随机算法"将序列打乱，从而使得输入序列满足"假设的分布"，以此来得到更小的平均情况运行时间值
     *
     *   如何知道输入序列取某一排列的概率呢？答案是不知道
     *   在实际情况中，要么已知输入序列满足特定分布（输入序列满足的分布决定输入序列的所有可能排列及其概率），或者假设输入序列的分布（如"均匀随机"的，即输入序列取全排列中任意一种排列的概率都相等）
     *   Ⅰ. 根据输入序列满足的分布求出所有可能排列的概率
     *   Ⅱ. 使用定义求解平均情况运行时间
     *   Ⅲ. 若根据定义不好求解，则可进行 "概率分析"(如，"事件"、"随机变量"等)，如将插入排序的里层循环表示成一个随机变量: @link current page
     *
     *三. 期望运行时间
     *   通过随机数生成器将输入序列打乱，使打乱后的序列满足一定的分布，从而计算出来的平均情况运行时间
     *
     *   对于一个算法，最坏情况运行时间通常是固定的，但可以优化平均情况运行时间。
     *   可以假设输入序列满足特定的分布，并且在该分布下有比较小的平均情况运行时间。
     *   然后使用随机数生成器创造满足该分布的输入序列，就可以得到比较小的期望运行时间(等同于期望的比较小的平均情况运行时间)。
     *
     */
    public static void main(String[] argv) {
        sl();
        chapter5_1And5_2And5_3();
    }
    /**
     *插入排序的运行时间分析
     *
     *最坏情况运行时间
     *  1 + 2 + ... + n-1 = (n-1)*n/2
     * 导致最坏情况的输入序列: 逆序的序列
     *
     *平均情况运行时间
     * 输入序列的假设: 均匀随机
     * 1).根据定义求
     *   排列       有序    排列2     排列3    ...    逆序
     *   运行时间    n-1                            (n-1)*n/2
     *   概率       1/n!                           1/n!
     *   n个数的全排共n!种，将每一种列出来，然后求解通常比较繁琐
     *
     * 2).概率分析
     *   随机变量X:  里层循环的总比较次数
     *   随机变量Xi: 第i次里层循环的比较次数
     *   X = X1 + X2 + ... + X(n-1)
     *
     *   平均情况运行时间 = (n-1) * EX
     *
     *   雇佣问题的概率分析: @link Chapter 5.1 and 5.2 and 5.3 / 第二: 平均情况
     */
    static void sl() {}

    /**Chapter 5.1 and 5.2 and 5.3
     *
     *雇用问题(找最值)
     *  依次面试 n 个应聘者，如果发现当前面试者更合适，就雇用当前的，直到面完第 n 个
     *
     *list[n]
     *person = list[0];
     *for i from 1 to n:
     *   if(decide(list[i], person)):        # 面试 list[i]，面试费用记为 Di
     *      person = list[i]   # 辞退 person, 费用记为 A(i-1), 雇用 list[i]，雇用费用记为 Ci
     *
     *面试总费用: n * D
     *雇佣总费用: m * C, 假设共雇用 m 个人
     *  以三个人为例子，他们的编号分别是 1 2 3，他们的排名是全排列中的任意一种 1 2 3； 1 3 2； 2 1 3； 2 3 1； 3 1 2； 3 2 1
     *  eg 对于 3 2 1 这样的序列，需要雇用 1 次，花费 1*C
     *     对于 1 2 3 这样的序列，需要雇用 n 次，花费 n*C
     *
     *第一: 最坏情况
     *  最坏情况: 将所有人都雇佣一次。雇佣总花费: n*C
     *
     *第二: 平均情况
     *  输入序列假设: 均匀随机
     *  1).根据平均情况运行时间的定义求解(以3个人为例)
     *     排列     1 2 3； 1 3 2； 2 1 3； 2 3 1； 3 1 2； 3 2 1
     *     雇佣次数  3      2       2       2      1       1
     *     概率     1/3!   1/3!    1/3!    1/3!   1/3!    1/3!
     *
     *   加权平均数 = 1/3! * 3 + 1/3! * 2 + 1/3! * 2 + 1/3! * 2 + 1/3! * 1 + 1/3! * 1
     *           = 1/3! * (3 + 2 + 2 + 2 + 1 + 1) = 11/6
     *  2).从概率角度求解(以3个人为例)
     *    随机变量X: 雇用的次数
     *    X   1      2      3
     *    P  2!/3!  3/3!   1/3!
     *
     *    使用 EX 表示雇佣人数的平均值:
     *    EX = 1/3! * 3 + (1/2) * 2 + 1/3 * 1
     *       = 1/3! * 3 + (1/3! * 2 + 1/3! * 2 + 1/3! * 2) + (1/3! * 1 + 1/3! * 1)
     *       = 11/6
     *
     *    如果是n个人，P(X = i) 这个概率不好直接求解，@link 如下，第三: 平均情况的详细分析
     *
     *第三: 平均情况的详细分析
     * 随机变量X: 雇用的人数 (雇佣次数)
     * X的取值: 1,   2,    3,   ...,  n
     *  P(X): P(1) p(2)  p(3)       P(n)
     *
     * 总费用: C*X
     * 总费用期望: C*EX
     *
     * 试验:    依次独立重复的面试 n 个人
     * 基本事件: (雇，雇/不雇，... ，雇/不雇)，共 n 个人
     * 样本空间: { (雇，雇/不雇，... ，雇/不雇) }, 共 2^(n-1) 个元素
     *
     * P(X=1) = (n-1)! / n! = 1/n, ..., P(x=i) 似乎并不好求
     *
     * 每一个基本事件的概率也不好求
     *
     * 换一个角度分析:
     *   rank(1), rank(2), ..., rank(n).    rank(i) 表示第 i 位应聘者的排名
     *   <rank(1), rank(2), ..., rank(n)> 是其中一种排列方式
     *   <rank(2), rank(1), ..., rank(n)> 也是
     *   这样的排列有 A(n,n) = n! 种, 每一种排列方式等概率(因为我们假设了输入序列是均匀随机的)
     *
     *   令 X = X1 + X2 +...+ Xi +...+ Xn.       Xi 表示第 i 个人是否被雇用 = 1，被雇佣
     *                                                                   0，不被雇用
     *       P(Xi = 1) = 1/i
     *
     *    EX = EX1 + EX2 +...+ EXi +...+ EXn
     *       = 1/1 + 1/2 +...+ 1/i +...+ 1/n
     *
     *    令 f(x) = 1/x, f(x)递减
     *      上界: ∫(1,n) f(x)dx = ∫(1,n) 1/xdx = ln(n)
     *      下界: ∫(1,n+1) f(x)dx = ∫(1,n+1) 1/xdx = ln(n+1)
     *
     *第四: 从以上分析可知: 输入序列的分布如果是均匀随机的，则平均情况费用为 C*lnn
     *     而实际情况是，输入序列不一定是均匀随机的，则可使用随机数创造一个均匀随机的序列，这样期望费用 = 平均情况费用
     *
     *为雇用问题创造随机输入序列: 使用随机数生成器产生 n 个数的随机序列，且该序列满足上述输入序列的分布假设
     *
     *list[n]
     *person = list[0];
     *for i from 1 to n:
     *    r = RANDOM(i, n)  # 等概率的在 i ~ n 中产生数字
     *    if(decide(list[r], person)):
     *       person = list[r]
     *    swap list[i], list[r]  # 秀
     *
     *
     *RANDOM(1,n): 等可能(1/n概率)的随机的产生数字1 ~ n
     *    将RANDOM(1, n)调用n次
     *            i1 i2 i3 ... in     1/n*1/n*...*1/n= 1/n^n 概率  @link Chapter1_5-1
     *
     *    将RANDOM(1, n)调用n次，且i不重复
     *            i1 i2 i3 ... in     1/n * [(1/n) / (n-1)/n] * [(1/n) / (n-2)/n] *... = 1/n!
     *
     *rd[n] = F[RANDOM(1, n)]... 不重复的产生n个数的随机序列
     *list[n]
     *person = lowest;
     *for i from 1 to n:
     *    r = rd[i]
     *    if(decide(list[r], person)):  # 如果当前面试者更合适
     *       person = list[r]  # 辞掉person, 雇用当前面试者，雇用一个面试者花费费用记为C
     *
     */
    static void chapter5_1And5_2And5_3() {}
}
