package com.juice.alg.part1.chapter3;

public class Chapter3 {
    /**
     *算法时间复杂度的计算使用其渐近效率，如下例子:
     *   1. 插入排序的运行时间为 T(n) = C1*n^2 + C2*n + C3
     *   2. 忽略低阶项后，其时间复杂度写成 Θ(n^2), 它表示
     *      存在常数 D1, D2, 和 N, 使得 n >= N 时， D1*n^2  <=  T(n)  <=  D2*n^2
     *   此即为，考虑算法的渐近效率，说白了，就是求算法运行时间的渐近"上界"和"下界".
     *
     *
     *渐近记号
     *  1. T(n) = Θ(g(n))
     *     存在常数 D1, D2, 和 N, 使得 n >= N 时， D1*g(n)  <=  T(n)  <=  D2*g(n)
     *     从函数图像上看，T(n) 夹入 D1*g(n) 与 D2*g(n) 之间
     *
     *     此记号表明: D1*g(n) 是 T(n) 的渐近下界(而且是渐近下确界)，D2*g(n) 是 T(n) 的渐近上界(而且是渐近上确界)
     *
     *  2. T(n) = O(g(n))
     *     存在常数 D2, 和 N, 使得 n >= N 时， T(n)  <=  D2*g(n)
     *     从函数图像上看，T(n) 在  D2*g(n) 下面
     *
     *     此记号表明: D2*g(n) 是 T(n) 的渐近上界
     *
     *     1). T(n) = o(g(n)):  T(n)  <=  D2*g(n)  and  lim g(n)/T(n) = ∞
     *         o 描述了 D2*g(n) 是 T(n) 的渐近上界，而且不是紧确的
     *
     *  3. T(n) = Ω(g(n))
     *     存在常数 D1, 和 N, 使得 n >= N 时， D1*g(n)  <=  T(n)
     *     从函数图像上看，T(n) 在 D1*g(n) 上面
     *
     *     此记号表明: D1*g(n) 是 T(n) 的渐近下界
     *
     *     1). T(n) = w(g(n)):  D1*g(n)  <=  T(n)  and  lim T(n)/g(n) = ∞
     *         w 描述了 D1*g(n) 是 T(n) 的渐近下界，而且不是紧确的
     *
     */

    public static void main(String[] argv) {

    }




}
