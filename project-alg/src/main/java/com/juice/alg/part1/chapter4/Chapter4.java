package com.juice.alg.part1.chapter4;

public class Chapter4 {
    /**
     *Chapter 4 分治策略
     *
     *分治策略思想
     *  分解(Divide):  将问题划分成若干子问题，子问题的形式和原问题相同，只是规模更小
     *  解决(Conquer): 递归地求解子问题，当子问题的规模足够小，停止递归，直接求解
     *  合并(Combine): 将子问题的解合并成原问题的解
     *
     *递归式
     *  递归式与分治策略是紧密相关的，使用递归式可以很自然的刻画分治算法的运行时间。
     *
     *  例如，归并排序 {@link com.juice.alg.part1.chapter2.Chapter2#merge_sort(int[])} 的最坏情况运行时间 T(n) 的递归式为:
     *    T(n) = Θ(1)               若 n == 1
     *         = 2*T(n/2) + Θ(n)    若 n >  1
     *
     *  递归式有几种求解方法:
     *    - Chapter 4.3 用代入法求解递归式, 猜测一个界，然后证明之
     *    - Chapter 4.4 用递归树求解递归式, 将递归式转化成递归树求解
     *    - Chapter 4.5 用主方法求解递归式, 可求解 T(n) = a*T(n/b) + f(n), a>=1, b>1 此种递归式的界
     *
     */
    public static void main(String[] argv) {

    }

    /**
     *Chapter 4.3 用代入法求解递归式
     */

    /**
     *Chapter 4.4 用递归树求解递归式
     *
     *T(n) = m*T(n/k) + f(n), f(n)为本次分解+合并的消耗
     * m决定树的茂盛，m越小，partition/merge次数越少
     * k决定树的高度，k越大，树越矮，每次partition/merge的规模越小
     *
     *如T(n) = 3*T(n/4) + n^2
     *                                      [n]                                   第一层
     *            [n/4]                    [n/4]                   [n/4]          第二层    第一次分解，n/4      1次merge, 1*n^2                           , 3份
     *    [n/16]  [n/16]  [n/16]   [n/16]  [n/16] [n/16]   [n/16]  [n/16] [n/16]  第三层    第二次分解，n/4^2    3次merge, 3*(n/4)^2                       , 3^2份
     *    ...
     *    ...                               [1]                             ...   第x+1层   第x次分解，n/4^x    3^(x-1)次merge, 3^(x-1) * [n/4^(x-1)]^2   , 3^x份
     *
     * 1.n/4^x = 1 ==> 4^x = n ==> x=log4(n)  树的高度=根节点的高度(根节点到叶节点的最长简单路径上边的条数)=x
     * 2.分解+合并的消耗之和
     *   = 1*n^2 + 3*(n/4)^2 + 3^2 * [n/4^(2)]^2 +...+ 3^(x-1) * [n/4^(x-1)]^2
     *   = n^2 * [1 + 3/16 + (3/16)^2 + (3/16)^3 +...+ (3/16)^(x-1)]
     *   = C*n^2*(1-3/16^x)
     *   = C*(n^2 - 3^(log4(n)))
     * 3.解决的消耗之和
     *     第x层数量3^x <= n，其中3^x = 3^[log4(n)] = n^[log4(3)]
     *   = T(1) * n^[log4(3)]
     *
     *影响速度的因素: m,k,f(n)
     */

    /**
     *Chapter 4.5 用主方法求解递归式
     */



}
