package com.fresh.juice.alg.part1.chapter5;

public class Chapter5_4 {

    /*
     *Chapter 5.4.1
     *
     *一: 一年有 n 天(通常取 365 )，一屋子里面必须达到多少人，使得其中两个人生日相同的概率 >= 50%？
     *
     *①
     *  k 个人，编号从 1 ~ k，每个人的生日与其他人无关，都是 n 天中的某一天
     *  令 i = 1, 2, ..., k. 令 bi 表示编号为 i 的人的生日, bi ∈ [1, n]. 令 r = 1, 2, ..., n
     *
     *  对任意的 i = 1, 2, ..., k. P(bi = r) = 1/n    即任意某个人生日是第 r 天的概率为 1/n
     *
     *  事件 A: 编号为 i 的人的生日与编号为 j 的人的生日相同
     *  P(A) = Σ(r=1~n){P(bi=r ∩ bj=r)} , bi=r, bj=r 这两个事件相互独立
     *  P(A) = Σ(r=1~n){P(bi=r) * P(bj=r)} = Σ(r=1~n){1/n^2} = 1/n
     *
     *
     *②
     *求 1 - P(每个人生日都不相同) >= 1/2                 //P(每个人生日都不相同) = n*(n-1)*...*(n-k+1)/n^k.
     *
     *定义事件 A(i): 对于所有的 j<i，j 与 i 生日不相同
     *定义事件 B(k): k 个人生日都不相同
     *   B(k) = A(k) ∩ B(k-1)                            , 其中 A(1) = B(1) = 1
     *   P(B(k)) = P(A(k) | B(k-1)) * P(B(k-1))
     *           = (n-k+1)/n * P(B(k-1))
     *           = ...
     *           = 1(1-1/n)(1-2/n)...(1-(k-1)/n)
     *           ...
     *   令 1 - P(B(k)) > 1/2 ==> ...
     *
     *③ 近似求解
     *试验:     k 个人，两两检测它们的生日是否为同一天。共检测 (k-1) + (k-2) +...+ 1 = k*(k-1)/2 个 <i, j> 次 (i<j)
     *基本事件:  (是同一天/不是同一天，是同一天/不是同一天，... ，是同一天/不是同一天)      k*(k-1)/2 元组
     *样本空间S: { (是同一天/不是同一天，是同一天/不是同一天，... ，是同一天/不是同一天) }  共 2^[k*(k-1)/2] 个元素
     *
     *随机变量X: 同一天生日的 <i,j> 对的个数
     *    X    0               , 1                 ,2 ...
     *  描述   每个人生日都不相同   , 仅存在两个人生日相同  ,存在两对<i,j>生日相同，但这两队之间的生日不一定相同 ...
     *    P
     *
     *X = X<1,1> + X<1,2> + ... + X<1,k> + X<2,3> + ... = Σ(i=1~n-1)Σ(j=i+1~n)X(i,j)
     *随机变量 X<i,j>: 编号为 i 的人与编号为 j 的人的生日是否相同:  1 //编号为 i 的人与编号为 j 的人的生日相同
     *                                                    0 //不相同
     *由 ① 可得, P(X<i,j> = 1) = 1/n
     *
     *EX = EΣ(i=1~n-1)Σ(j=i+1~n)X(i,j) = 1/n * k*(k-1)/2
     *令 EX >= 1  ==>  k*(k-1) >= 2*n
     */

    /*
     *Chapter 5.4.2
     *
     *二: 球与箱子
     *  将相同的球随机投到 b 个箱子，箱子编号为 1, 2, ..., b. 每次投球都是独立的，即某一次投球不知道前面投的球投到了哪个箱子.
     *  每一次投球，球等可能的落在每一个箱子中，概率为 1/b, 假设一个箱子可以容纳多个球. 投球的过程是伯努利试验，成功的概率为 1/b, 其中，成功是指球落入指定的箱子.
     *
     *  随机变量X: 落入指定箱子的球的数量
     *  X ~ b(k, n, 1/b)
     *  EX = np = n/b
     *
     *  随机变量X: 指定箱子落入第一个球所需的投球次数
     *  X ~ 几何分布(1/b)
     *  EX = b
     *
     *
     *  随机变量X: 使每个箱子至少有一个球，所需的投球次数
     *  X = X1 + ... + Xb, Xi 表示第 i 个箱子落入第一个球所需的投球次数
     *  EX = EX1 + ... + EXb = b^2
     *  这个界大了...
     *
     *  一次投球落在空箱子为一次命中
     *  随机变量Y: 获得 b 次命中所需的投球次数  //无限可数的随机变量
     *  Y = Y1 + ... + Yb, Yi 表示第 i-i 次命中后到第 i 次命中所需的投球次数    //定义在 n 次独立重复试验上的随机变量 X 的分解，即将 n 次独立重复试验分解成"若干"份。第 i 份记为 Xi, X = ΣXi
     *    Y1  1
     *    P   1
     *
     *    Y2  1          2                      3                      ...
     *    P   (b-1)/b    1/b * (b-1)/b          (1/b)^2 * (b-1)/b      ...
     *
     *    Yi  1          2                      3
     *    P   (b-i+1)/b  (i-1)/b * (b-i+1)/b    ((i-1)/b)^2 * (b-i+1)/b
     *
     *    Yi ~ 几何分布((b-i+1)/b)
     *    EYi = b/(b-i+1)
     *
     *  EY = EY1 + ... + EYb
     *     = Σ(i=1~b)EYi
     *     = Σ(i=1~b){ b/(b-i+1) }
     *     = b*Σ(i=1~b) { 1/(b-i+1) }
     *     = b*Σ(x=1~b) { 1/x }
     *     = b*(lnb + O(1))
     */

    /*
     *Chapter 5.4.3
     *
     *三: 特征序列
     *  抛一枚标准的硬币 n 次，最长连续正面的序列的期望长度是多少？
     *
     *  随机变量X: 最长连续正面的序列的长度
     *    X    0  1  2
     *    P
     *    P(X=0) = 1/2^n
     *    P(X=1) = n/2^n
     *    P(X=2) 不好求
     *
     *  每次试验之间相互之间依赖，等到试验完成统计所有试验结果之后才能得出结论:
     *
     *  X = MAX(X1, X2, ..., Xi, ...). Xi 表示第 i 个连续正面的子序列的长度
     *
     *  ΣXi <= n
     *
     *  EX = E{MAX(X1, X2, ..., Xi, ...)} <= EX1 + EX2 + ... + EXi + ...
     *                                     = E(X1 + X2 + ... + Xi + ...)
     *                                     = E(ΣXi)
     *    ΣXi    0  1  2  ...  j  ...  n
     *    P
     *    P(ΣXi = 0) = 1/2^n
     *    P(ΣXi = 1) = C(1,n)/2^n
     *    P(ΣXi = 2) = C(2,n)/2^n
     *    ...
     *    P(ΣXi = j) = C(j,n)/2^n
     *
     *  EX <= E(ΣXi) = 1/2^n * (Σj*C(j,n))
     *  todo
     */

    /*
     *Chapter 5.4.4
     *
     *[1,n] 的序列，选择 k，1<=k<n; 在 [1,k] 中选出最大值 max，在 [k+1,n] 中选出第一个大于 max 的
     *求: 选到最好应聘者事件的概率
     *
     *S:  选到最好应聘者的事件
     *Si: 最好应聘者是第i位置的事件
     *S = ∪(i=1->n)S(i)
     *P(S) = P( S(1) + S(2) + S(k) + S(k+1) + ... + S(n) )  ,S(i)互斥
     *  = P(S(1)) + P(S(2)) + ... + P(S(k+1)) + ... + P(S(n)) , P(S(1)) ~ P(S(k)) = 0
     *  = P(S(k+1)) + ... + P(S(n))
     *
     *S(i) = A(i) ∩ B(i) , i∈[k+1, n]，A(i)表示第i位置最大的事件，B(i)表示1~k位置的最大值>任意[k+1,i-1]位置的值
     *
     *P(S(i)) = P( A(i) ∩ B(i) ) ,A(i),B(i)独立
     *        = P(A(i)) * P(B(i))
     *
     *P(A(i)) = A(n-1,n-1) / A(n,n) = 1/n
     *P(B(i)) = P(1~i-1范围内，最大值出现在0~k) = C(1,k) * A(i-2,i-2) / A(i-1,i-1) = k/(i-1)
     *则P(S(i)) = k/n*(i-1)
     *
     *P(S) = k/n*k + k/n*(k+1) + ... + k/n*(n-1)
     *     = k/n*[1/k + 1/(k+1) + ... + 1/(n-1)]
     *  求得P(S)的下界k/n*(ln(n) - ln(k))
     *  f(k) = k/n*(ln(n) - ln(k))
     *  f'(k) = 1/n*(ln(n) - ln(k) -1) = 0 ==> k=n/e
     *  当k>n/e时，f'(k) < 0 , 递减
     *  当k<n/e时，f'(k) > 0 , 递增
     *  k=n/e时取到最大值f(n/e) = 1/e
     *
     *当k=n/e时，选到最好应聘者事件的概率至少是1/e
     */

}
