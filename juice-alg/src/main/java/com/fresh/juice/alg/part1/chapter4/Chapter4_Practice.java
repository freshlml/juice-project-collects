package com.fresh.juice.alg.part1.chapter4;

public class Chapter4_Practice {

    /*思考题4-5,芯片检测
      一块好的芯片总能准确报告另一块芯片的好坏，但坏芯片的报告结果不可信任

      三个芯片 A, B, C 两两检测
      1). 检测 B-C，假设得出结果"好-好"，则 B 和 C 状态一致，但不能确定他们是好是坏
      2). 检测 A-B
          若得出结果"好-好"，则 A 和 B 状态一致，但不能确定他们是好是坏
          若得出结果"好-坏"，则 A 是坏的，B 不能确定
          若得出结果"坏-好"，则 B 是坏的，A 不能确定
          若得出结果"坏-坏"，则 A，B 都不能确定是好是坏
      可见，对所有芯片两两检测，不能确定芯片的状态。注: n 个芯片，两两检测，共 n*(n+1)/2 种结果

      a. 证明: 如果超过 n/2 块芯片是坏的，则任何基于这种逐对检测的策略都无法确定哪些芯片是好的
        todo
        取某个芯片，与其他芯片逐一检测，得到 n-1 个其他芯片报告的结果，可相信的报告结果 < n/2，其他芯片报告的"好"/"坏"的总数可能 > n/2, 也可能 < n/2

      假定 n 个芯片中超过 n/2 块芯片是"好"的。测定一块芯片好坏的方法: 用该芯片与其他芯片逐一测试，统计其他芯片的报告结果
        1. 若 n 为偶数。待检测芯片记为 A
           若 A 为坏芯片，则其他芯片报告的结果为"坏"的数量 >= n/2 + 1，将 A 错误报告为"好"的数量 <  n/2 - 1
           若 A 为好芯片，则其他芯片报告的结果为"好"的数量 >= n/2，    将 A 错误报告为"坏"的数量 <  n/2
        2. 若 n 为奇数。待检测芯片记为 A
           若 A 为坏芯片，则其他芯片报告的结果为"坏"的数量 >= n/2 + 1，将 A 错误报告为"好"的数量 <  n/2
           若 A 为好芯片，则其他芯片报告的结果为"好"的数量 >= n/2，    将 A 错误报告为"坏"的数量 <= n/2
      故: 将 A 与其他芯片逐一测试，若报告为"坏"的数量 >= n/2 + 1，则该芯片为"坏"芯片，若报告为"好"的数量 >= n/2，则该芯片为"好"芯片

      b & c. 假定 n 个芯片中超过 n/2 块芯片是"好"的. 求如何检测出一块好的芯片
        1. 两两配对检测，保留所有结果是"好-好"的检测对，每个检测对留一片丢一片。
        2. 如果是其他情况全丢掉，剩下的芯片仍然满足好芯片多于坏芯片的假设。

        T(n) = T(n/2) + O(n)
     */
    int find(int[] a) {

        int n = a.length;

        if(n == 1) return a[0];
        if(n == 2) return a[0];

        boolean flag = (n % 2 != 0) && !isBad(a, n-1); //如果 n 为奇数，并且 a[n-1] 不是坏芯片
        if(flag) return a[n-1];

        int[] b = new int[n/2];
        //两两配对
        int j = 0;
        for(int i=0; i<n/2; i++) {
            if(check(a[i], a[n/2 + i]) == 0) { //"好-好"的检测结果，留一片丢一片
                b[j++] = a[i];
            }
            //其他舍弃
        }

        int r = find(b);
        return r;
    }
    //0: 好-好, 1: 好-坏, 2: 坏-好, 3: 坏-坏
    int check(int a, int b) {return 0;}
    boolean isBad(int[] a, int idx) {
        int n = a.length;
        int mi = n/2;
        int p = a[idx];
        int g = 0, h = 0;
        for(int i=0; i<n; i++) {
            if(i == idx) continue;
            int pj;
            if((pj = check(p, a[i])) == 1 || pj == 3) {
                h++;
                if(h >= mi + 1) return true;
            } else {
                g++;
                if(g >= mi) return false;
            }
        }
        return h >= mi + 1;
    }

    //思考题 4-6: Monge 矩阵
    // a: 使用归纳法即可证明:
    //    A[i][j]    +   A[i+1][j+1] <= A[i][j+1]    +  A[i+1][j]   ①
    //    A[i][j+1]  +   A[i+1][j+2] <= A[i+1][j+1]  +  A[i][j+2]   ②
    //    A[i+1][j]  +   A[i+2][j+2] <= A[i+2][j]    +  A[i+1][j+1] ③
    // ① + ② 得 A[i][j] + A[i+1][j+2] <= A[i+1][j] + A[i][j+2]
    // ① + ③ 得 A[i][j] + A[i+2][j+1] <= A[i+2][j] + A[i][j+1]
    //
    // c: 根据 Monge 矩阵性质，得 A[i][j-1] + A[i+1][j] <= A[i+1][j-1] + A[i][j] ①
    //    令 A[i][j] 为 i 行最左最小元素，则 A[i][j-1] > A[i][j]
    //    要让 ① 式成立，则必定有 A[i+1][j] <= A[i+1][j-1]
    //    依次类推，即可证明 f(1) <= f(2) <= f(3) <= ... <= f(m)
    //
    // d & e: 提取 A 的偶数行构造子矩阵 A', 递归的确认 A' 的最左最小元素，根据偶数行的最左最小元素确定奇数行的最左最小元素
    //     m
    //   m/2（偶数行）    m/2（奇数行）     1, m/2 - 1 + n
    //   m/4（偶数行） m/4（奇数行） ...    2, m/4 - 1 + n
    //   ...
    //   1（偶数行） 1（奇数行）     ...    x, m/2^x - 1 + n
    //
    // Ⅰ: 1 = m/2^x, m = 2^x, x = lgm
    // Ⅱ: T(n) = c * (m/2 + m/4 + ... + m/2^x + x*n - x)
    //          = c * (m - 1 + (n-1)*lgm)
    //          < c * (m + n*lgm)
    //     T(n) = O(m + n*lgm)

}
