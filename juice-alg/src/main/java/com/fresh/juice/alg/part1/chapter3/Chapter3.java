package com.fresh.juice.alg.part1.chapter3;

public class Chapter3 {
    /**
     *<pre>
     *算法运行效率的刻画:
     *   1. 虽然有时我们能够确定一个算法的精确运行时间，如插入排序的运行时间 T(n) = C1*n^2 + C2*n + C3，但是
     *      通常并不值得花力气计算多余的精度。对于足够大的输入，精确运行时间中的"倍增常量"和"低阶项"被输入规模本身的影响所支配
     *   2. 当输入规模足够大时，我们仅考虑影响算法运行时间的主要量级，即研究算法的渐进效率。我们
     *      使用渐进记号来表示算法的运行时间，如 T(n) = Θ(n^2)
     *
     *渐近记号:
     *  1. Θ 记号
     *     Θ(g(n)) 是一个集合: {f(n): 存在常数 D1, D2, 和 N, 使得 n >= N 时， D1*g(n)  <=  f(n)  <=  D2*g(n)}
     *
     *     使用 Θ 记号表示算法的运行时间 T(n) : T(n) = Θ(g(n))
     *        1). T(n) = Θ(g(n))  等同于  T(n) ∈ Θ(g(n))，即 D1*g(n)  <=  T(n)  <=  D2*g(n)
     *        2). 从函数图像上看，T(n) 夹入 D1*g(n) 与 D2*g(n) 之间
     *        2). 此记号表明: D1*g(n) 是 T(n) 的渐近下界(而且是渐近下确界)，D2*g(n) 是 T(n) 的渐近上界(而且是渐近上确界)
     *
     *  2. T(n) = O(g(n))
     *     存在常数 D2, 和 N, 使得 n >= N 时， T(n)  <=  D2*g(n)
     *     从函数图像上看，T(n) 在  D2*g(n) 下面
     *
     *     此记号表明: D2*g(n) 是 T(n) 的渐近上界
     *
     *     1). T(n) = o(g(n)):  T(n)  <  D2*g(n)  and  lim g(n)/T(n) = ∞
     *         o 描述了 D2*g(n) 是 T(n) 的渐近上界，而且不是紧确的
     *
     *  3. T(n) = Ω(g(n))
     *     存在常数 D1, 和 N, 使得 n >= N 时， D1*g(n)  <=  T(n)
     *     从函数图像上看，T(n) 在 D1*g(n) 上面
     *
     *     此记号表明: D1*g(n) 是 T(n) 的渐近下界
     *
     *     1). T(n) = w(g(n)):  D1*g(n)  <  T(n)  and  lim T(n)/g(n) = ∞
     *         w 描述了 D1*g(n) 是 T(n) 的渐近下界，而且不是紧确的
     *</pre>
     *
     *<p>part8/appendix.md/附录 A 求和</p>
     */

    public static void main(String[] argv) {

    }

    //定理 3.3 ~ 3.9 证明得要点
    // x÷a = s ... m = s + m÷a  , x >= 0, a > 0
    // s 为整数商, m 为余数, 0 <= m÷a < 1


    //一元二次函数的渐近式: f(n) = a*n^2 + b*n + c, a!=0
    //  f(n) = Θ(n^2)
    //即证:  C1*n^2 <= f(n) <= C2*n^2
    //证明一: f(n) <= C2*n^2
    //       a*n^2 + b*n + c <= C2*n^2
    //       (a-C2) * n^2 + b*n + c <= 0
    //       只需 a < C2, 使之开口向下，必然存在，对于足够大的 n 使之 <= 0 成立
    //证明二: C1*n^2 <= f(n)
    //       同理，可得 a > C1

    //d 次多项式的渐进式: p(n) = Σ(i=0-d) Ai * n^i, d 为非负整数, Ad > 0
    //  p(n) = Θ(n^d)
    //即证: 存在C1, C2, 使得 C1*n^d <= p(n) <= C2*n^d 成立
    //     C1 <= A0 / n^d + A1 / n^(d-1) + ... + A(d-1) / n^1 + Ad / n^0 <= C2
    //  令 f(n) = A0 / n^d + A1 / n^(d-1) + ... + A(d-1) / n^1 + Ad / n^0
    //即证: 存在C1, C2, 使得 C1 <= f(n) <= C2
    //  令 A = max(A0, A1, ..., Ad), A' = min(A0, A1, ..., Ad)
    //    A' * ( 1 / n^d + 1 / n^(d-1) + ... + 1 / n + 1 / n^0 ) <=  f(n) <= A * ( 1 / n^d + 1 / n^(d-1) + ... + 1 / n + 1 / n^0 )
    //  令 g(n) = 1 / n^d + 1 / n^(d-1) + ... + 1 / n + 1 / n^0
    //  当 n >= 1 时, 1 <= g(n) <= d
    //  可得 A' <= f(n) <= A*d
    //得证

}
