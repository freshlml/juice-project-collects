package com.juice.alg.part1.chapter1;

public class Chapter1 {
    /**
     *第一: 子序列数量计算
     *   n 个元素的集合 {A1, A2, A3, ... , An}, 其子集个数: 2^n = ΣC(n, i)[i=0->n]
     *   n 个元素的序列 <X1, X2, X3, ... , Xn>, 其子序列（如: X1,X3）数量: 2^n - 1
     *
     *第二: 排列数，组合数: @link 计数原理.xmind
     *   n 个数的全排列: A(n, n) = n!
     *
     *   从 n 个元素的集合中取 k 个数: C(n, k)
     *   C(n, k) * k! = A(n, k) = n! / (n-k)! = n * (n-1) * ... * (n-k+1)
     *
     *
     *练习题 1.1-4: 最短路径问题和旅行商问题有哪些相似、不同之处？
     *  最短路径问题只需计算两点之间的最短路径即是该问题的最优解
     *  旅行商问题: 每辆车需要投递货物到几个地址，每辆车的最短总距离是按其最优投递顺序投递货物所行驶的总距离
     *
     *
     *练习题 1.2-2: 对规模为 n 的输入，插入排序取 8*n^2，归并排序取 64*n*lgN，求哪些 n 值，插入排序优于归并排序？
     *  即求哪些 n 值，使得 8*n*n < 64*n*lgN 成立
     *  令 F(n) = 8*n - 64*lgN
     *
     *  F'(n) = 8 - 64/(n*ln2)
     *  当 n = 8/ln2 时 F'(n) = 0
     *    ==> n < 8/ln2 时，单调递减；n > 8/ln2 时，单调递增；极小值 F(8/ln2) = 8*8/ln2 - 64*ln(8/ln2) < 0
     *    ==> 存在 n 使得 F(n) = 8*n - 64*lgN < 0, 即 8*n < 64*lgN 成立
     *
     *  F(11) < 0
     *  F(2)  < 0
     *  ...
     *  F(43) < 0                              //临界值
     *  F(44) > 0
     *
     *  得，当 n <= 43 时，8*n^2 优于 64*n*lgN
     *
     */
    public static void main(String[] argv) {

    }

}
